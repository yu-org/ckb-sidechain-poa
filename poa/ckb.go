// Generated by Molecule 0.7.3
// Generated by Moleculec-Go 0.1.9

package poa

import (
	"bytes"
	"encoding/binary"
	"errors"
	"strconv"
	"strings"
)

type Number uint32

const HeaderSizeUint uint32 = 4

// Byte is the primitive type
type Byte [1]byte

func NewByte(b byte) Byte {
	return Byte([1]byte{b})
}
func ByteDefault() Byte {
	return Byte([1]byte{0})
}
func ByteFromSliceUnchecked(slice []byte) *Byte {
	b := new(Byte)
	b[0] = slice[0]
	return b
}
func (b *Byte) AsSlice() []byte {
	return b[:]
}
func ByteFromSlice(slice []byte, _compatible bool) (*Byte, error) {
	if len(slice) != 1 {
		return nil, errors.New("TotalSizeNotMatch")
	}
	b := new(Byte)
	b[0] = slice[0]
	return b, nil
}
func unpackNumber(b []byte) Number {
	bytesBuffer := bytes.NewBuffer(b)
	var x Number
	binary.Read(bytesBuffer, binary.LittleEndian, &x)
	return x
}
func packNumber(num Number) []byte {
	b := make([]byte, 4)
	binary.LittleEndian.PutUint32(b, uint32(num))
	return b
}

type BytesBuilder struct {
	inner []Byte
}

func (s *BytesBuilder) Build() Bytes {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := Bytes{inner: b.Bytes()}

	return sb
}

func (s *BytesBuilder) Set(v []Byte) *BytesBuilder {
	s.inner = v
	return s
}
func (s *BytesBuilder) Push(v Byte) *BytesBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *BytesBuilder) Extend(iter []Byte) *BytesBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *BytesBuilder) Replace(index uint, v Byte) *Byte {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewBytesBuilder() *BytesBuilder {
	return &BytesBuilder{[]Byte{}}
}

type Bytes struct {
	inner []byte
}

func BytesFromSliceUnchecked(slice []byte) *Bytes {
	return &Bytes{inner: slice}
}
func (s *Bytes) AsSlice() []byte {
	return s.inner
}

func BytesDefault() Bytes {
	return *BytesFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func BytesFromSlice(slice []byte, _compatible bool) (*Bytes, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Bytes", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &Bytes{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(1*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &Bytes{inner: slice}, nil
}

func (s *Bytes) TotalSize() uint {
	return uint(HeaderSizeUint) + 1*s.ItemCount()
}
func (s *Bytes) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *Bytes) Len() uint {
	return s.ItemCount()
}
func (s *Bytes) IsEmpty() bool {
	return s.Len() == 0
}

// if *Byte is nil, index is out of bounds
func (s *Bytes) Get(index uint) *Byte {
	var re *Byte
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 1*index
		end := start + 1
		re = ByteFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *Bytes) RawData() []byte {
	return s.inner[HeaderSizeUint:]
}

func (s *Bytes) AsBuilder() BytesBuilder {
	size := s.ItemCount()
	t := NewBytesBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type Uint32Builder struct {
	inner [4]Byte
}

func NewUint32Builder() *Uint32Builder {
	return &Uint32Builder{inner: [4]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Uint32Builder) Build() Uint32 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint32{inner: b.Bytes()}
}

func (s *Uint32Builder) Set(v [4]Byte) *Uint32Builder {
	s.inner = v
	return s
}

func (s *Uint32Builder) Nth0(v Byte) *Uint32Builder {
	s.inner[0] = v
	return s
}

func (s *Uint32Builder) Nth1(v Byte) *Uint32Builder {
	s.inner[1] = v
	return s
}

func (s *Uint32Builder) Nth2(v Byte) *Uint32Builder {
	s.inner[2] = v
	return s
}

func (s *Uint32Builder) Nth3(v Byte) *Uint32Builder {
	s.inner[3] = v
	return s
}

type Uint32 struct {
	inner []byte
}

func Uint32FromSliceUnchecked(slice []byte) *Uint32 {
	return &Uint32{inner: slice}
}
func (s *Uint32) AsSlice() []byte {
	return s.inner
}

func Uint32Default() Uint32 {
	return *Uint32FromSliceUnchecked([]byte{0, 0, 0, 0})
}

func Uint32FromSlice(slice []byte, _compatible bool) (*Uint32, error) {
	sliceLen := len(slice)
	if sliceLen != 4 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint32", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(4)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Uint32{inner: slice}, nil
}

func (s *Uint32) RawData() []byte {
	return s.inner
}

func (s *Uint32) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint32) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint32) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Uint32) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Uint32) AsBuilder() Uint32Builder {
	t := NewUint32Builder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	return *t
}

type Uint64Builder struct {
	inner [8]Byte
}

func NewUint64Builder() *Uint64Builder {
	return &Uint64Builder{inner: [8]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Uint64Builder) Build() Uint64 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint64{inner: b.Bytes()}
}

func (s *Uint64Builder) Set(v [8]Byte) *Uint64Builder {
	s.inner = v
	return s
}

func (s *Uint64Builder) Nth0(v Byte) *Uint64Builder {
	s.inner[0] = v
	return s
}

func (s *Uint64Builder) Nth1(v Byte) *Uint64Builder {
	s.inner[1] = v
	return s
}

func (s *Uint64Builder) Nth2(v Byte) *Uint64Builder {
	s.inner[2] = v
	return s
}

func (s *Uint64Builder) Nth3(v Byte) *Uint64Builder {
	s.inner[3] = v
	return s
}

func (s *Uint64Builder) Nth4(v Byte) *Uint64Builder {
	s.inner[4] = v
	return s
}

func (s *Uint64Builder) Nth5(v Byte) *Uint64Builder {
	s.inner[5] = v
	return s
}

func (s *Uint64Builder) Nth6(v Byte) *Uint64Builder {
	s.inner[6] = v
	return s
}

func (s *Uint64Builder) Nth7(v Byte) *Uint64Builder {
	s.inner[7] = v
	return s
}

type Uint64 struct {
	inner []byte
}

func Uint64FromSliceUnchecked(slice []byte) *Uint64 {
	return &Uint64{inner: slice}
}
func (s *Uint64) AsSlice() []byte {
	return s.inner
}

func Uint64Default() Uint64 {
	return *Uint64FromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0})
}

func Uint64FromSlice(slice []byte, _compatible bool) (*Uint64, error) {
	sliceLen := len(slice)
	if sliceLen != 8 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint64", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(8)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Uint64{inner: slice}, nil
}

func (s *Uint64) RawData() []byte {
	return s.inner
}

func (s *Uint64) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint64) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint64) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Uint64) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Uint64) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *Uint64) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *Uint64) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *Uint64) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *Uint64) AsBuilder() Uint64Builder {
	t := NewUint64Builder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	return *t
}

type Uint128Builder struct {
	inner [16]Byte
}

func NewUint128Builder() *Uint128Builder {
	return &Uint128Builder{inner: [16]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Uint128Builder) Build() Uint128 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint128{inner: b.Bytes()}
}

func (s *Uint128Builder) Set(v [16]Byte) *Uint128Builder {
	s.inner = v
	return s
}

func (s *Uint128Builder) Nth0(v Byte) *Uint128Builder {
	s.inner[0] = v
	return s
}

func (s *Uint128Builder) Nth1(v Byte) *Uint128Builder {
	s.inner[1] = v
	return s
}

func (s *Uint128Builder) Nth2(v Byte) *Uint128Builder {
	s.inner[2] = v
	return s
}

func (s *Uint128Builder) Nth3(v Byte) *Uint128Builder {
	s.inner[3] = v
	return s
}

func (s *Uint128Builder) Nth4(v Byte) *Uint128Builder {
	s.inner[4] = v
	return s
}

func (s *Uint128Builder) Nth5(v Byte) *Uint128Builder {
	s.inner[5] = v
	return s
}

func (s *Uint128Builder) Nth6(v Byte) *Uint128Builder {
	s.inner[6] = v
	return s
}

func (s *Uint128Builder) Nth7(v Byte) *Uint128Builder {
	s.inner[7] = v
	return s
}

func (s *Uint128Builder) Nth8(v Byte) *Uint128Builder {
	s.inner[8] = v
	return s
}

func (s *Uint128Builder) Nth9(v Byte) *Uint128Builder {
	s.inner[9] = v
	return s
}

func (s *Uint128Builder) Nth10(v Byte) *Uint128Builder {
	s.inner[10] = v
	return s
}

func (s *Uint128Builder) Nth11(v Byte) *Uint128Builder {
	s.inner[11] = v
	return s
}

func (s *Uint128Builder) Nth12(v Byte) *Uint128Builder {
	s.inner[12] = v
	return s
}

func (s *Uint128Builder) Nth13(v Byte) *Uint128Builder {
	s.inner[13] = v
	return s
}

func (s *Uint128Builder) Nth14(v Byte) *Uint128Builder {
	s.inner[14] = v
	return s
}

func (s *Uint128Builder) Nth15(v Byte) *Uint128Builder {
	s.inner[15] = v
	return s
}

type Uint128 struct {
	inner []byte
}

func Uint128FromSliceUnchecked(slice []byte) *Uint128 {
	return &Uint128{inner: slice}
}
func (s *Uint128) AsSlice() []byte {
	return s.inner
}

func Uint128Default() Uint128 {
	return *Uint128FromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func Uint128FromSlice(slice []byte, _compatible bool) (*Uint128, error) {
	sliceLen := len(slice)
	if sliceLen != 16 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint128", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(16)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Uint128{inner: slice}, nil
}

func (s *Uint128) RawData() []byte {
	return s.inner
}

func (s *Uint128) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint128) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint128) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Uint128) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Uint128) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *Uint128) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *Uint128) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *Uint128) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *Uint128) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *Uint128) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *Uint128) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *Uint128) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *Uint128) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *Uint128) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *Uint128) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *Uint128) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *Uint128) AsBuilder() Uint128Builder {
	t := NewUint128Builder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	return *t
}

type Uint256Builder struct {
	inner [32]Byte
}

func NewUint256Builder() *Uint256Builder {
	return &Uint256Builder{inner: [32]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Uint256Builder) Build() Uint256 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint256{inner: b.Bytes()}
}

func (s *Uint256Builder) Set(v [32]Byte) *Uint256Builder {
	s.inner = v
	return s
}

func (s *Uint256Builder) Nth0(v Byte) *Uint256Builder {
	s.inner[0] = v
	return s
}

func (s *Uint256Builder) Nth1(v Byte) *Uint256Builder {
	s.inner[1] = v
	return s
}

func (s *Uint256Builder) Nth2(v Byte) *Uint256Builder {
	s.inner[2] = v
	return s
}

func (s *Uint256Builder) Nth3(v Byte) *Uint256Builder {
	s.inner[3] = v
	return s
}

func (s *Uint256Builder) Nth4(v Byte) *Uint256Builder {
	s.inner[4] = v
	return s
}

func (s *Uint256Builder) Nth5(v Byte) *Uint256Builder {
	s.inner[5] = v
	return s
}

func (s *Uint256Builder) Nth6(v Byte) *Uint256Builder {
	s.inner[6] = v
	return s
}

func (s *Uint256Builder) Nth7(v Byte) *Uint256Builder {
	s.inner[7] = v
	return s
}

func (s *Uint256Builder) Nth8(v Byte) *Uint256Builder {
	s.inner[8] = v
	return s
}

func (s *Uint256Builder) Nth9(v Byte) *Uint256Builder {
	s.inner[9] = v
	return s
}

func (s *Uint256Builder) Nth10(v Byte) *Uint256Builder {
	s.inner[10] = v
	return s
}

func (s *Uint256Builder) Nth11(v Byte) *Uint256Builder {
	s.inner[11] = v
	return s
}

func (s *Uint256Builder) Nth12(v Byte) *Uint256Builder {
	s.inner[12] = v
	return s
}

func (s *Uint256Builder) Nth13(v Byte) *Uint256Builder {
	s.inner[13] = v
	return s
}

func (s *Uint256Builder) Nth14(v Byte) *Uint256Builder {
	s.inner[14] = v
	return s
}

func (s *Uint256Builder) Nth15(v Byte) *Uint256Builder {
	s.inner[15] = v
	return s
}

func (s *Uint256Builder) Nth16(v Byte) *Uint256Builder {
	s.inner[16] = v
	return s
}

func (s *Uint256Builder) Nth17(v Byte) *Uint256Builder {
	s.inner[17] = v
	return s
}

func (s *Uint256Builder) Nth18(v Byte) *Uint256Builder {
	s.inner[18] = v
	return s
}

func (s *Uint256Builder) Nth19(v Byte) *Uint256Builder {
	s.inner[19] = v
	return s
}

func (s *Uint256Builder) Nth20(v Byte) *Uint256Builder {
	s.inner[20] = v
	return s
}

func (s *Uint256Builder) Nth21(v Byte) *Uint256Builder {
	s.inner[21] = v
	return s
}

func (s *Uint256Builder) Nth22(v Byte) *Uint256Builder {
	s.inner[22] = v
	return s
}

func (s *Uint256Builder) Nth23(v Byte) *Uint256Builder {
	s.inner[23] = v
	return s
}

func (s *Uint256Builder) Nth24(v Byte) *Uint256Builder {
	s.inner[24] = v
	return s
}

func (s *Uint256Builder) Nth25(v Byte) *Uint256Builder {
	s.inner[25] = v
	return s
}

func (s *Uint256Builder) Nth26(v Byte) *Uint256Builder {
	s.inner[26] = v
	return s
}

func (s *Uint256Builder) Nth27(v Byte) *Uint256Builder {
	s.inner[27] = v
	return s
}

func (s *Uint256Builder) Nth28(v Byte) *Uint256Builder {
	s.inner[28] = v
	return s
}

func (s *Uint256Builder) Nth29(v Byte) *Uint256Builder {
	s.inner[29] = v
	return s
}

func (s *Uint256Builder) Nth30(v Byte) *Uint256Builder {
	s.inner[30] = v
	return s
}

func (s *Uint256Builder) Nth31(v Byte) *Uint256Builder {
	s.inner[31] = v
	return s
}

type Uint256 struct {
	inner []byte
}

func Uint256FromSliceUnchecked(slice []byte) *Uint256 {
	return &Uint256{inner: slice}
}
func (s *Uint256) AsSlice() []byte {
	return s.inner
}

func Uint256Default() Uint256 {
	return *Uint256FromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func Uint256FromSlice(slice []byte, _compatible bool) (*Uint256, error) {
	sliceLen := len(slice)
	if sliceLen != 32 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint256", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(32)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Uint256{inner: slice}, nil
}

func (s *Uint256) RawData() []byte {
	return s.inner
}

func (s *Uint256) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint256) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint256) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Uint256) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Uint256) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *Uint256) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *Uint256) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *Uint256) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *Uint256) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *Uint256) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *Uint256) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *Uint256) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *Uint256) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *Uint256) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *Uint256) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *Uint256) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *Uint256) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *Uint256) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *Uint256) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *Uint256) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *Uint256) Nth20() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[20:21])
	return ret
}

func (s *Uint256) Nth21() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[21:22])
	return ret
}

func (s *Uint256) Nth22() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[22:23])
	return ret
}

func (s *Uint256) Nth23() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[23:24])
	return ret
}

func (s *Uint256) Nth24() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[24:25])
	return ret
}

func (s *Uint256) Nth25() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[25:26])
	return ret
}

func (s *Uint256) Nth26() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[26:27])
	return ret
}

func (s *Uint256) Nth27() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[27:28])
	return ret
}

func (s *Uint256) Nth28() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[28:29])
	return ret
}

func (s *Uint256) Nth29() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[29:30])
	return ret
}

func (s *Uint256) Nth30() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[30:31])
	return ret
}

func (s *Uint256) Nth31() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[31:32])
	return ret
}

func (s *Uint256) AsBuilder() Uint256Builder {
	t := NewUint256Builder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	t.Nth20(*s.Nth20())
	t.Nth21(*s.Nth21())
	t.Nth22(*s.Nth22())
	t.Nth23(*s.Nth23())
	t.Nth24(*s.Nth24())
	t.Nth25(*s.Nth25())
	t.Nth26(*s.Nth26())
	t.Nth27(*s.Nth27())
	t.Nth28(*s.Nth28())
	t.Nth29(*s.Nth29())
	t.Nth30(*s.Nth30())
	t.Nth31(*s.Nth31())
	return *t
}

type HashBuilder struct {
	inner [32]Byte
}

func NewHashBuilder() *HashBuilder {
	return &HashBuilder{inner: [32]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *HashBuilder) Build() Hash {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Hash{inner: b.Bytes()}
}

func (s *HashBuilder) Set(v [32]Byte) *HashBuilder {
	s.inner = v
	return s
}

func (s *HashBuilder) Nth0(v Byte) *HashBuilder {
	s.inner[0] = v
	return s
}

func (s *HashBuilder) Nth1(v Byte) *HashBuilder {
	s.inner[1] = v
	return s
}

func (s *HashBuilder) Nth2(v Byte) *HashBuilder {
	s.inner[2] = v
	return s
}

func (s *HashBuilder) Nth3(v Byte) *HashBuilder {
	s.inner[3] = v
	return s
}

func (s *HashBuilder) Nth4(v Byte) *HashBuilder {
	s.inner[4] = v
	return s
}

func (s *HashBuilder) Nth5(v Byte) *HashBuilder {
	s.inner[5] = v
	return s
}

func (s *HashBuilder) Nth6(v Byte) *HashBuilder {
	s.inner[6] = v
	return s
}

func (s *HashBuilder) Nth7(v Byte) *HashBuilder {
	s.inner[7] = v
	return s
}

func (s *HashBuilder) Nth8(v Byte) *HashBuilder {
	s.inner[8] = v
	return s
}

func (s *HashBuilder) Nth9(v Byte) *HashBuilder {
	s.inner[9] = v
	return s
}

func (s *HashBuilder) Nth10(v Byte) *HashBuilder {
	s.inner[10] = v
	return s
}

func (s *HashBuilder) Nth11(v Byte) *HashBuilder {
	s.inner[11] = v
	return s
}

func (s *HashBuilder) Nth12(v Byte) *HashBuilder {
	s.inner[12] = v
	return s
}

func (s *HashBuilder) Nth13(v Byte) *HashBuilder {
	s.inner[13] = v
	return s
}

func (s *HashBuilder) Nth14(v Byte) *HashBuilder {
	s.inner[14] = v
	return s
}

func (s *HashBuilder) Nth15(v Byte) *HashBuilder {
	s.inner[15] = v
	return s
}

func (s *HashBuilder) Nth16(v Byte) *HashBuilder {
	s.inner[16] = v
	return s
}

func (s *HashBuilder) Nth17(v Byte) *HashBuilder {
	s.inner[17] = v
	return s
}

func (s *HashBuilder) Nth18(v Byte) *HashBuilder {
	s.inner[18] = v
	return s
}

func (s *HashBuilder) Nth19(v Byte) *HashBuilder {
	s.inner[19] = v
	return s
}

func (s *HashBuilder) Nth20(v Byte) *HashBuilder {
	s.inner[20] = v
	return s
}

func (s *HashBuilder) Nth21(v Byte) *HashBuilder {
	s.inner[21] = v
	return s
}

func (s *HashBuilder) Nth22(v Byte) *HashBuilder {
	s.inner[22] = v
	return s
}

func (s *HashBuilder) Nth23(v Byte) *HashBuilder {
	s.inner[23] = v
	return s
}

func (s *HashBuilder) Nth24(v Byte) *HashBuilder {
	s.inner[24] = v
	return s
}

func (s *HashBuilder) Nth25(v Byte) *HashBuilder {
	s.inner[25] = v
	return s
}

func (s *HashBuilder) Nth26(v Byte) *HashBuilder {
	s.inner[26] = v
	return s
}

func (s *HashBuilder) Nth27(v Byte) *HashBuilder {
	s.inner[27] = v
	return s
}

func (s *HashBuilder) Nth28(v Byte) *HashBuilder {
	s.inner[28] = v
	return s
}

func (s *HashBuilder) Nth29(v Byte) *HashBuilder {
	s.inner[29] = v
	return s
}

func (s *HashBuilder) Nth30(v Byte) *HashBuilder {
	s.inner[30] = v
	return s
}

func (s *HashBuilder) Nth31(v Byte) *HashBuilder {
	s.inner[31] = v
	return s
}

type Hash struct {
	inner []byte
}

func HashFromSliceUnchecked(slice []byte) *Hash {
	return &Hash{inner: slice}
}
func (s *Hash) AsSlice() []byte {
	return s.inner
}

func HashDefault() Hash {
	return *HashFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func HashFromSlice(slice []byte, _compatible bool) (*Hash, error) {
	sliceLen := len(slice)
	if sliceLen != 32 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Hash", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(32)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Hash{inner: slice}, nil
}

func (s *Hash) RawData() []byte {
	return s.inner
}

func (s *Hash) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Hash) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Hash) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Hash) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Hash) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *Hash) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *Hash) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *Hash) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *Hash) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *Hash) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *Hash) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *Hash) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *Hash) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *Hash) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *Hash) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *Hash) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *Hash) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *Hash) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *Hash) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *Hash) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *Hash) Nth20() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[20:21])
	return ret
}

func (s *Hash) Nth21() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[21:22])
	return ret
}

func (s *Hash) Nth22() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[22:23])
	return ret
}

func (s *Hash) Nth23() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[23:24])
	return ret
}

func (s *Hash) Nth24() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[24:25])
	return ret
}

func (s *Hash) Nth25() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[25:26])
	return ret
}

func (s *Hash) Nth26() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[26:27])
	return ret
}

func (s *Hash) Nth27() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[27:28])
	return ret
}

func (s *Hash) Nth28() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[28:29])
	return ret
}

func (s *Hash) Nth29() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[29:30])
	return ret
}

func (s *Hash) Nth30() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[30:31])
	return ret
}

func (s *Hash) Nth31() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[31:32])
	return ret
}

func (s *Hash) AsBuilder() HashBuilder {
	t := NewHashBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	t.Nth20(*s.Nth20())
	t.Nth21(*s.Nth21())
	t.Nth22(*s.Nth22())
	t.Nth23(*s.Nth23())
	t.Nth24(*s.Nth24())
	t.Nth25(*s.Nth25())
	t.Nth26(*s.Nth26())
	t.Nth27(*s.Nth27())
	t.Nth28(*s.Nth28())
	t.Nth29(*s.Nth29())
	t.Nth30(*s.Nth30())
	t.Nth31(*s.Nth31())
	return *t
}

type EvidenceBuilder struct {
	height              Uint64
	block_hash          Hash
	txn_root            Hash
	state_root          Hash
	signatures          Signatures
	increate_validators ValidatorsChange
	decreate_validators ValidatorsChange
}

func (s *EvidenceBuilder) Build() Evidence {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (7 + 1)
	offsets := make([]uint32, 0, 7)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.height.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.block_hash.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.txn_root.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.state_root.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.signatures.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.increate_validators.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.decreate_validators.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.height.AsSlice())
	b.Write(s.block_hash.AsSlice())
	b.Write(s.txn_root.AsSlice())
	b.Write(s.state_root.AsSlice())
	b.Write(s.signatures.AsSlice())
	b.Write(s.increate_validators.AsSlice())
	b.Write(s.decreate_validators.AsSlice())
	return Evidence{inner: b.Bytes()}
}

func (s *EvidenceBuilder) Height(v Uint64) *EvidenceBuilder {
	s.height = v
	return s
}

func (s *EvidenceBuilder) BlockHash(v Hash) *EvidenceBuilder {
	s.block_hash = v
	return s
}

func (s *EvidenceBuilder) TxnRoot(v Hash) *EvidenceBuilder {
	s.txn_root = v
	return s
}

func (s *EvidenceBuilder) StateRoot(v Hash) *EvidenceBuilder {
	s.state_root = v
	return s
}

func (s *EvidenceBuilder) Signatures(v Signatures) *EvidenceBuilder {
	s.signatures = v
	return s
}

func (s *EvidenceBuilder) IncreateValidators(v ValidatorsChange) *EvidenceBuilder {
	s.increate_validators = v
	return s
}

func (s *EvidenceBuilder) DecreateValidators(v ValidatorsChange) *EvidenceBuilder {
	s.decreate_validators = v
	return s
}

func NewEvidenceBuilder() *EvidenceBuilder {
	return &EvidenceBuilder{height: Uint64Default(), block_hash: HashDefault(), txn_root: HashDefault(), state_root: HashDefault(), signatures: SignaturesDefault(), increate_validators: ValidatorsChangeDefault(), decreate_validators: ValidatorsChangeDefault()}
}

type Evidence struct {
	inner []byte
}

func EvidenceFromSliceUnchecked(slice []byte) *Evidence {
	return &Evidence{inner: slice}
}
func (s *Evidence) AsSlice() []byte {
	return s.inner
}

func EvidenceDefault() Evidence {
	return *EvidenceFromSliceUnchecked([]byte{140, 0, 0, 0, 32, 0, 0, 0, 40, 0, 0, 0, 72, 0, 0, 0, 104, 0, 0, 0, 136, 0, 0, 0, 140, 0, 0, 0, 140, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0})
}

func EvidenceFromSlice(slice []byte, compatible bool) (*Evidence, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Evidence", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Evidence", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 7 == 0 {
		return &Evidence{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Evidence", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Evidence", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Evidence", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 7 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 7 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = SignaturesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ValidatorsChangeFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ValidatorsChangeFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	return &Evidence{inner: slice}, nil
}

func (s *Evidence) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Evidence) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Evidence) Len() uint {
	return s.FieldCount()
}
func (s *Evidence) IsEmpty() bool {
	return s.Len() == 0
}
func (s *Evidence) CountExtraFields() uint {
	return s.FieldCount() - 7
}

func (s *Evidence) HasExtraFields() bool {
	return 7 != s.FieldCount()
}

func (s *Evidence) Height() *Uint64 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *Evidence) BlockHash() *Hash {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *Evidence) TxnRoot() *Hash {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *Evidence) StateRoot() *Hash {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *Evidence) Signatures() *Signatures {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return SignaturesFromSliceUnchecked(s.inner[start:end])
}

func (s *Evidence) IncreateValidators() *ValidatorsChange {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return ValidatorsChangeFromSliceUnchecked(s.inner[start:end])
}

func (s *Evidence) DecreateValidators() *ValidatorsChange {
	var ret *ValidatorsChange
	start := unpackNumber(s.inner[28:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[32:])
		ret = ValidatorsChangeFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = ValidatorsChangeFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *Evidence) AsBuilder() EvidenceBuilder {
	ret := NewEvidenceBuilder().Height(*s.Height()).BlockHash(*s.BlockHash()).TxnRoot(*s.TxnRoot()).StateRoot(*s.StateRoot()).Signatures(*s.Signatures()).IncreateValidators(*s.IncreateValidators()).DecreateValidators(*s.DecreateValidators())
	return *ret
}

type EvidencesBuilder struct {
	inner []Evidence
}

func (s *EvidencesBuilder) Build() Evidences {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return Evidences{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return Evidences{inner: b.Bytes()}
}

func (s *EvidencesBuilder) Set(v []Evidence) *EvidencesBuilder {
	s.inner = v
	return s
}
func (s *EvidencesBuilder) Push(v Evidence) *EvidencesBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *EvidencesBuilder) Extend(iter []Evidence) *EvidencesBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *EvidencesBuilder) Replace(index uint, v Evidence) *Evidence {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewEvidencesBuilder() *EvidencesBuilder {
	return &EvidencesBuilder{[]Evidence{}}
}

type Evidences struct {
	inner []byte
}

func EvidencesFromSliceUnchecked(slice []byte) *Evidences {
	return &Evidences{inner: slice}
}
func (s *Evidences) AsSlice() []byte {
	return s.inner
}

func EvidencesDefault() Evidences {
	return *EvidencesFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func EvidencesFromSlice(slice []byte, compatible bool) (*Evidences, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Evidences", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Evidences", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &Evidences{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Evidences", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Evidences", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Evidences", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "Evidences"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := EvidenceFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &Evidences{inner: slice}, nil
}

func (s *Evidences) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Evidences) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Evidences) Len() uint {
	return s.ItemCount()
}
func (s *Evidences) IsEmpty() bool {
	return s.Len() == 0
}

// if *Evidence is nil, index is out of bounds
func (s *Evidences) Get(index uint) *Evidence {
	var b *Evidence
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = EvidenceFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = EvidenceFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *Evidences) AsBuilder() EvidencesBuilder {
	size := s.ItemCount()
	t := NewEvidencesBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type ValidatorsChangeBuilder struct {
	isNone bool
	inner  Validators
}

func NewValidatorsChangeBuilder() *ValidatorsChangeBuilder {
	return &ValidatorsChangeBuilder{isNone: true, inner: ValidatorsDefault()}
}
func (s *ValidatorsChangeBuilder) Set(v Validators) *ValidatorsChangeBuilder {
	s.isNone = false
	s.inner = v
	return s
}
func (s *ValidatorsChangeBuilder) Build() ValidatorsChange {
	var ret ValidatorsChange
	if s.isNone {
		ret = ValidatorsChange{inner: []byte{}}
	} else {
		ret = ValidatorsChange{inner: s.inner.AsSlice()}
	}
	return ret
}

type ValidatorsChange struct {
	inner []byte
}

func ValidatorsChangeFromSliceUnchecked(slice []byte) *ValidatorsChange {
	return &ValidatorsChange{inner: slice}
}
func (s *ValidatorsChange) AsSlice() []byte {
	return s.inner
}

func ValidatorsChangeDefault() ValidatorsChange {
	return *ValidatorsChangeFromSliceUnchecked([]byte{})
}

func ValidatorsChangeFromSlice(slice []byte, compatible bool) (*ValidatorsChange, error) {
	if len(slice) == 0 {
		return &ValidatorsChange{inner: slice}, nil
	}

	_, err := ValidatorsFromSlice(slice, compatible)
	if err != nil {
		return nil, err
	}
	return &ValidatorsChange{inner: slice}, nil
}

func (s *ValidatorsChange) IntoValidators() (*Validators, error) {
	if s.IsNone() {
		return nil, errors.New("No data")
	}
	return ValidatorsFromSliceUnchecked(s.AsSlice()), nil
}
func (s *ValidatorsChange) IsSome() bool {
	return len(s.inner) != 0
}
func (s *ValidatorsChange) IsNone() bool {
	return len(s.inner) == 0
}
func (s *ValidatorsChange) AsBuilder() ValidatorsChangeBuilder {
	var ret = NewValidatorsChangeBuilder()
	if s.IsSome() {
		ret.Set(*ValidatorsFromSliceUnchecked(s.AsSlice()))
	}
	return *ret
}

type ValidatorsBuilder struct {
	inner []Bytes
}

func (s *ValidatorsBuilder) Build() Validators {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return Validators{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return Validators{inner: b.Bytes()}
}

func (s *ValidatorsBuilder) Set(v []Bytes) *ValidatorsBuilder {
	s.inner = v
	return s
}
func (s *ValidatorsBuilder) Push(v Bytes) *ValidatorsBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *ValidatorsBuilder) Extend(iter []Bytes) *ValidatorsBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *ValidatorsBuilder) Replace(index uint, v Bytes) *Bytes {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewValidatorsBuilder() *ValidatorsBuilder {
	return &ValidatorsBuilder{[]Bytes{}}
}

type Validators struct {
	inner []byte
}

func ValidatorsFromSliceUnchecked(slice []byte) *Validators {
	return &Validators{inner: slice}
}
func (s *Validators) AsSlice() []byte {
	return s.inner
}

func ValidatorsDefault() Validators {
	return *ValidatorsFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func ValidatorsFromSlice(slice []byte, compatible bool) (*Validators, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Validators", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Validators", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &Validators{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Validators", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Validators", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Validators", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "Validators"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := BytesFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &Validators{inner: slice}, nil
}

func (s *Validators) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Validators) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Validators) Len() uint {
	return s.ItemCount()
}
func (s *Validators) IsEmpty() bool {
	return s.Len() == 0
}

// if *Bytes is nil, index is out of bounds
func (s *Validators) Get(index uint) *Bytes {
	var b *Bytes
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = BytesFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = BytesFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *Validators) AsBuilder() ValidatorsBuilder {
	size := s.ItemCount()
	t := NewValidatorsBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type SignaturesBuilder struct {
	inner []Bytes
}

func (s *SignaturesBuilder) Build() Signatures {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return Signatures{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return Signatures{inner: b.Bytes()}
}

func (s *SignaturesBuilder) Set(v []Bytes) *SignaturesBuilder {
	s.inner = v
	return s
}
func (s *SignaturesBuilder) Push(v Bytes) *SignaturesBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *SignaturesBuilder) Extend(iter []Bytes) *SignaturesBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *SignaturesBuilder) Replace(index uint, v Bytes) *Bytes {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewSignaturesBuilder() *SignaturesBuilder {
	return &SignaturesBuilder{[]Bytes{}}
}

type Signatures struct {
	inner []byte
}

func SignaturesFromSliceUnchecked(slice []byte) *Signatures {
	return &Signatures{inner: slice}
}
func (s *Signatures) AsSlice() []byte {
	return s.inner
}

func SignaturesDefault() Signatures {
	return *SignaturesFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func SignaturesFromSlice(slice []byte, compatible bool) (*Signatures, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Signatures", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Signatures", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &Signatures{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Signatures", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Signatures", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Signatures", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "Signatures"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := BytesFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &Signatures{inner: slice}, nil
}

func (s *Signatures) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Signatures) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Signatures) Len() uint {
	return s.ItemCount()
}
func (s *Signatures) IsEmpty() bool {
	return s.Len() == 0
}

// if *Bytes is nil, index is out of bounds
func (s *Signatures) Get(index uint) *Bytes {
	var b *Bytes
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = BytesFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = BytesFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *Signatures) AsBuilder() SignaturesBuilder {
	size := s.ItemCount()
	t := NewSignaturesBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}
